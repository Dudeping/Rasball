public static void TarCreateFromStream()
{

// 创建输出流。不必是磁盘，可以是内存流等。
string tarOutFn = @"d:\test.tar";
Stream outStream = File.Create(tarOutFn);
TarOutputStream tarOutputStream = new TarOutputStream(outStream);

CreateTarArchive(tarOutputStream, @"D:\文件夹");

// 关闭归档文件也关闭底层流。
tarOutputStream.Close();
}

private static void CreateTarArchive(TarOutputStream tarOutputStream, string sourceDirectory)
{
// 可选地，为目录本身写一个条目。
// TarEntry tarEntry = TarEntry.CreateEntryFromFile(sourceDirectory);
// tarOutputStream.PutNextEntry(tarEntry);
// 将每个文件写入tar。
string[] filenames = Directory.GetFiles(sourceDirectory);

foreach (string filename in filenames)
{
using (Stream inputStream = File.OpenRead(filename))
{
int idxStart = filename.LastIndexOf('\\') + 1;
string tarName = filename.Substring(idxStart, filename.Length - idxStart);
long fileSize = inputStream.Length;
TarEntry entry = TarEntry.CreateTarEntry(tarName);

// 必须设置大小，否则当输出超过时，TAROutPutsFipe将失败。
entry.Size = fileSize;

// 在写入数据之前，将条目添加到TAR流中。
tarOutputStream.PutNextEntry(entry);

// 这是从TracSovi.Read EngyCype复制的
byte[] localBuffer = new byte[32 * 1024];
while (true)
{
int numRead = inputStream.Read(localBuffer, 0, localBuffer.Length);
if (numRead <= 0)
{
break;
}
tarOutputStream.Write(localBuffer, 0, numRead);
}
}
tarOutputStream.CloseEntry();
}
// 递归。如果不需要就删除。
//string[] directories = Directory.GetDirectories(sourceDirectory);
//foreach (string directory in directories)
//{
// CreateTarArchive(tarOutputStream, directory);
//}
}


本周主要是对上周制定的防篡改方案进行具体的实施规划，并和相关部门进行讨论。

在上周制定加密方案的可行性分析环节中，对加密算法本身和 .NET 提供的安全模型有了更加深入的了解；
关于加密，本来打算大量使用非对称加密以保证数据机密和完整，但是验证发现非对称在大数据量加密上会花很大代价；
对于数据格式，一开始准备使用自定义的二进制格式，最后采用了更加简单方便的 Json 格式。
