public static void TarCreateFromStream()
{

// 创建输出流。不必是磁盘，可以是内存流等。
string tarOutFn = @"d:\test.tar";
Stream outStream = File.Create(tarOutFn);
TarOutputStream tarOutputStream = new TarOutputStream(outStream);

CreateTarArchive(tarOutputStream, @"D:\文件夹");

// 关闭归档文件也关闭底层流。
tarOutputStream.Close();
}

private static void CreateTarArchive(TarOutputStream tarOutputStream, string sourceDirectory)
{
// 可选地，为目录本身写一个条目。
// TarEntry tarEntry = TarEntry.CreateEntryFromFile(sourceDirectory);
// tarOutputStream.PutNextEntry(tarEntry);
// 将每个文件写入tar。
string[] filenames = Directory.GetFiles(sourceDirectory);

foreach (string filename in filenames)
{
using (Stream inputStream = File.OpenRead(filename))
{
int idxStart = filename.LastIndexOf('\\') + 1;
string tarName = filename.Substring(idxStart, filename.Length - idxStart);
long fileSize = inputStream.Length;
TarEntry entry = TarEntry.CreateTarEntry(tarName);

// 必须设置大小，否则当输出超过时，TAROutPutsFipe将失败。
entry.Size = fileSize;

// 在写入数据之前，将条目添加到TAR流中。
tarOutputStream.PutNextEntry(entry);

// 这是从TracSovi.Read EngyCype复制的
byte[] localBuffer = new byte[32 * 1024];
while (true)
{
int numRead = inputStream.Read(localBuffer, 0, localBuffer.Length);
if (numRead <= 0)
{
break;
}
tarOutputStream.Write(localBuffer, 0, numRead);
}
}
tarOutputStream.CloseEntry();
}
// 递归。如果不需要就删除。
//string[] directories = Directory.GetDirectories(sourceDirectory);
//foreach (string directory in directories)
//{
// CreateTarArchive(tarOutputStream, directory);
//}
}












Runtime 修改

1. 完成 Json 组件统一集成接口定义(暂未分库)；
2. 完成提交事务时判断当前事务中是否有执行失败的语句处理。

CustOrders Web 案例

1. 完成界面布局、呈现、交互；
2. 完成与已有服务对接(仿照PB逻辑)；
3. 完成技术选型以及基本实现的讲解；
4. 使用 Blazor 尝试纯粹的客户端方案。

下周
协助解决 Docker 服务端问题，保证主流程走通

本周主要是协助开发 CustOrders 的 Web 案例；
完成案例开发后，我们发现这个 Web 方案其实放弃掉了之前推荐的 API 方案；
那么更能够延续之前方案的应该是推荐一个纯粹的 Web 客户端，就是我们周五时实践的 Blazor 方案；
该方案无论从入门门槛，还是框架本身的简单方便、编程模型的先进性等等，无疑是现在最佳的 Web UI 方案；
但是实践发现，因其暂未提供基架模板、未完全支持模型上的属性、调试困难、加上我们现有组件对该框架集成度低，
种种原因，导致开发效率极其低下，但是该方案值得持续关注。

本月主要是在做 Runtime 的工作；
在本月工作中发现，在以前，IDE 开发相对于 Runtime 是较随意的，Runtime 的几乎每处修改我们都会先讨论、确认；
这倒逼我们去反复验证自己方案的合理性和可行性，然后去说服其他成员同意，该机制本身在不断提高小组的整体理性程度；
相反，IDE 开发更多的时候都是商量着把功能完成就行，没有去严格推行上面这个机制，这才是 Runtime 越做越好的根本所在。
