public static void TarCreateFromStream()
{

// 创建输出流。不必是磁盘，可以是内存流等。
string tarOutFn = @"d:\test.tar";
Stream outStream = File.Create(tarOutFn);
TarOutputStream tarOutputStream = new TarOutputStream(outStream);

CreateTarArchive(tarOutputStream, @"D:\文件夹");

// 关闭归档文件也关闭底层流。
tarOutputStream.Close();
}

private static void CreateTarArchive(TarOutputStream tarOutputStream, string sourceDirectory)
{
// 可选地，为目录本身写一个条目。
// TarEntry tarEntry = TarEntry.CreateEntryFromFile(sourceDirectory);
// tarOutputStream.PutNextEntry(tarEntry);
// 将每个文件写入tar。
string[] filenames = Directory.GetFiles(sourceDirectory);

foreach (string filename in filenames)
{
using (Stream inputStream = File.OpenRead(filename))
{
int idxStart = filename.LastIndexOf('\\') + 1;
string tarName = filename.Substring(idxStart, filename.Length - idxStart);
long fileSize = inputStream.Length;
TarEntry entry = TarEntry.CreateTarEntry(tarName);

// 必须设置大小，否则当输出超过时，TAROutPutsFipe将失败。
entry.Size = fileSize;

// 在写入数据之前，将条目添加到TAR流中。
tarOutputStream.PutNextEntry(entry);

// 这是从TracSovi.Read EngyCype复制的
byte[] localBuffer = new byte[32 * 1024];
while (true)
{
int numRead = inputStream.Read(localBuffer, 0, localBuffer.Length);
if (numRead <= 0)
{
break;
}
tarOutputStream.Write(localBuffer, 0, numRead);
}
}
tarOutputStream.CloseEntry();
}
// 递归。如果不需要就删除。
//string[] directories = Directory.GetDirectories(sourceDirectory);
//foreach (string directory in directories)
//{
// CreateTarArchive(tarOutputStream, directory);
//}
}


周

确定了集群下阶段开发目标，基于 Solution 添加/编辑容器编排，然后支持部署到本地(开发环境)，内网(测试环境)，云服务(生产环境)；
在参与 Deploy 接口设计时，错误地去根据 VS 的界面来进行接口定义，没有进一步分析到其本质，导致接口功能不单一，扩展实现过于复杂；

本周还是挺有触动的，之前因为安全问题，便采用了将校验逻辑放在服务器端的方案，首先是没有将其作为两个问题来处理，
其次，该方案的缺陷最后慢慢显现了出来，如果要保证数据完全可靠，我们需要编写极其复杂逻辑的来保证并发下数据库操作的一致性；

后来 John 提出了根据业务逻辑拆分数据库后，还是没有进一步去思考要将校验逻辑放到客户端去，后来 John 再次提出将校验逻辑放到客户端，
并解决了我们的疑惑后，这时整个模块突然变得简单起来；我们一开始把本质搞清楚后，便忙着围绕它进行一些接口设计和实现，没有再跳出来从大局上进行整体分析；

对于安全问题，我们一直在 OAuth 的使用上下功夫来保证安全，但是 OAuth 的本质是解决客户端访问资源的权限问题，
无法解决我们将自己的通行客户端完全交到别人手上的问题，这种问题需要另外的防破解方案来解决。

月
本月主要在参与新框架的基础设施建设，如 ApiTester 接口定义， Solution 文件操作封装，Solution 属性操作接口提供；

更加深刻理解了设计先行：编程语言提供了诸如类型、运算、异步、委托等解决问题的基础，然后编程准则进一步规范了命名、类设计、集合使用等等，
但这些都仅仅是代码层面的，到了业务层面，我们首先需要根据业务的本质抽象对象、接口，搭建框架，这时特定的场景有一些设计模式，设计原则可以参考;

在开发中发现，VS 越来越趋近于云原生开发 IDE，虽然说仅限于 Azure，首先它可以让用户直接连接并使用云服务(存储、数据库、缓存)，
还有一些方面做了强制，新建项目启用验证功能时，使用 AD 服务代替了以前的 Identity，K8S 开发过程只支持 Azure，不支持本地，
最后，提供了比较完整的 Azure 发布选项，当然，这些只需要有一个 Azure 账号，所有操作都不需要离开 VS；
另外，还在完善 DevOps 支持(GitHub、Azure Pipelines、Azure 已经形成完整流程)，和 Codespace(除了界面在本地，其余都在云上，可以通过 Live Share 很方便与人协作)。
